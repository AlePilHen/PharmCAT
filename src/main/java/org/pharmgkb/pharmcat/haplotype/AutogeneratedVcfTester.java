package org.pharmgkb.pharmcat.haplotype;

import java.io.IOException;
import java.io.PrintWriter;
import java.lang.invoke.MethodHandles;
import java.nio.file.DirectoryStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;
import org.checkerframework.checker.nullness.qual.Nullable;
import org.pharmgkb.common.io.util.CliHelper;
import org.pharmgkb.common.util.IoUtils;
import org.pharmgkb.pharmcat.definition.model.DefinitionExemption;
import org.pharmgkb.pharmcat.haplotype.model.DiplotypeMatch;
import org.pharmgkb.pharmcat.haplotype.model.Result;
import org.pharmgkb.pharmcat.util.DataManager;


/**
 * This class runs all autogenerated test VCFs against the {@link NamedAlleleMatcher}.
 *
 * @author Mark Woon
 */
public class AutogeneratedVcfTester implements AutoCloseable {
  private static final ResultSerializer sf_resultSerializer = new ResultSerializer();
  private final Path m_exemptionsFile;
  private final Path m_outputDir;
  private final PrintWriter m_writer;
  private final boolean m_saveData;
  private int m_numTests;
  private int m_numFailures;


  private AutogeneratedVcfTester(Path outputDir, boolean saveData) throws IOException {
    m_exemptionsFile = DataManager.DEFAULT_DEFINITION_DIR.resolve(DataManager.EXEMPTIONS_JSON_FILE_NAME);
    if (!Files.isRegularFile(m_exemptionsFile)) {
      throw new IllegalStateException("Cannot find exemptions file: " + m_exemptionsFile);
    }
    m_outputDir = outputDir;
    m_writer = new PrintWriter(Files.newBufferedWriter(m_outputDir.resolve("autogenerated_test_report.txt")));
    m_saveData = saveData;
  }

  @Override
  public void close() {
    IoUtils.closeQuietly(m_writer);
  }


  public static void main(String[] args) {
    try {
      CliHelper cliHelper = new CliHelper(MethodHandles.lookup().lookupClass())
          .addOption("vcf", "vcf-dir", "test VCF directory", true, "vcf")
          .addOption("o", "output-dir", "output directory", true, "o")
          .addOption("g", "gene", "restrict to specific gene", false, "g")
          .addOption("s", "save", "save all results")
          ;

      cliHelper.execute(args, cli -> {
        try{
          Path vcfDir = cliHelper.getValidDirectory("vcf", false);
          Path outputDir = cliHelper.getValidDirectory("o", true);
          try (AutogeneratedVcfTester tester = new AutogeneratedVcfTester(outputDir, cliHelper.hasOption("s"))) {
            if (cli.hasOption("g")) {
              Path geneDir = vcfDir.resolve(Objects.requireNonNull(cliHelper.getValue("g")));
              if (Files.isDirectory(geneDir)) {
                System.out.println(geneDir + " is not a valid directory");
              }
              tester.testGene(geneDir);
            } else {
              tester.testAllGenes(vcfDir);
            }
          }
          return 0;

        } catch (Exception ex) {
          ex.printStackTrace();
          return 1;
        }
      });
    } catch (Exception ex) {
      ex.printStackTrace();
    }
  }


  private void testAllGenes(Path vcfDir) throws IOException {
    try (DirectoryStream<Path> geneDirStream = Files.newDirectoryStream(vcfDir)) {
      for (Path geneDir : geneDirStream) {
        if (Files.isDirectory(geneDir)) {
          testGene(geneDir);
          m_writer.flush();
        }
      }
    }

    NumberFormat numFormatter = NumberFormat.getInstance();
    m_writer.println();
    m_writer.println("# tests  = " + numFormatter.format(m_numTests));
    m_writer.println("# passed = " + numFormatter.format(m_numTests - m_numFailures));
    m_writer.println("# failed = " + numFormatter.format(m_numFailures));
  }

  private void testGene(Path geneDir) throws IOException {

    String gene = geneDir.getFileName().toString();
    System.out.println("Testing " + gene + "...\n");
    Path definitionFile = DataManager.DEFAULT_DEFINITION_DIR.resolve(gene + "_translation.json");
    if (!Files.isRegularFile(definitionFile)) {
      throw new IllegalStateException("Cannot find definition file for " + gene + ": " + definitionFile);
    }
    DefinitionReader definitionReader = new DefinitionReader();
    definitionReader.read(definitionFile);
    definitionReader.readExemptions(m_exemptionsFile);
    DefinitionExemption exemptions = definitionReader.getExemption(gene);
    NamedAlleleMatcher namedAlleleMatcher = new NamedAlleleMatcher(definitionReader, true, false);

    try (DirectoryStream<Path> vcfStream = Files.newDirectoryStream(geneDir)) {
      for (Path vcfFile : vcfStream) {
        if (Files.isRegularFile(vcfFile) && vcfFile.toString().endsWith(".vcf")) {
          try {
            test(namedAlleleMatcher, vcfFile, exemptions);
          } catch (RuntimeException ex) {
            throw new RuntimeException("Error on " + vcfFile, ex);
          }
        }
      }
    }
    System.out.println();
  }


  private void test(NamedAlleleMatcher namedAlleleMatcher, Path vcfFile, @Nullable DefinitionExemption exemption)
      throws IOException {

    m_numTests += 1;
    VcfReader vcfReader = new VcfReader(vcfFile);
    String expectedDiplotype = vcfReader.getVcfMetadata().getRawProperties().get("PharmCATnamedAlleles").get(0);
    List<String> expectedAlleles = Arrays.asList(expectedDiplotype.split("/"));
    boolean hasUnknownCall = expectedAlleles.contains("?");
    boolean hasComboCall = !hasUnknownCall && vcfFile.getFileName().toString().contains("noCall");

    Result result = namedAlleleMatcher.call(vcfFile);
    // only compare top candidates
    List<DiplotypeMatch> topPairs = new ArrayList<>();
    List<DiplotypeMatch> alternatePairs = new ArrayList<>();
    if (result.getGeneCalls().get(0).getDiplotypes().size() > 0) {
      Set<DiplotypeMatch> pairs = result.getGeneCalls().get(0).getDiplotypes();
      int topScore = pairs.iterator().next().getScore();
      for (DiplotypeMatch match : pairs) {
        if (match.getScore() == topScore) {
          topPairs.add(match);
        } else {
          alternatePairs.add(match);
        }
      }
    }

    if (hasUnknownCall || hasComboCall) {
      if (topPairs.size() > 0) {
        fail(vcfFile, result, topPairs, alternatePairs, "no call (" + expectedDiplotype + ")", exemption);
      }
      return;
    }
    if (topPairs.size() != 1) {
      fail(vcfFile, result, topPairs, alternatePairs, expectedDiplotype, exemption);
      return;
    }

    Collections.sort(expectedAlleles);
    String expected = String.join("/", expectedAlleles);

    List<String> rezAlleles = Arrays.asList(topPairs.get(0).getName().split("/"));
    Collections.sort(rezAlleles);
    String rez = String.join("/", rezAlleles);

    if (!rez.equals(expected)) {
      fail(vcfFile, result, topPairs, alternatePairs, expectedDiplotype, exemption);
    } else {
      if (m_saveData) {
        saveData(vcfFile, result);
      }
    }
  }


  private void fail(Path vcfFile, Result result, List<DiplotypeMatch> topPairs, List<DiplotypeMatch> alternatePairs,
      String expected, @Nullable DefinitionExemption exemption) throws IOException {
    m_numFailures += 1;
    //noinspection UnstableApiUsage
    String baseFilename = com.google.common.io.Files.getNameWithoutExtension(vcfFile.getFileName().toString());
    String actual = topPairs.stream()
        .map(DiplotypeMatch::getName)
        .collect(Collectors.joining(", "));
    String alt = null;
    if (alternatePairs.size() > 0) {
      alt = alternatePairs.stream()
          .map(m -> m.getName() + " (" + m.getScore() + ")")
          .collect(Collectors.joining(", "));
    }

    System.out.println("* " + baseFilename);
    System.out.println("  Expected: " + expected);
    System.out.println("    Actual: " + actual);
    if (alt != null) {
      System.out.println("      Alts: " + alt);
    }

    m_writer.println(baseFilename);
    m_writer.println("  Expected: " + expected);
    m_writer.print("    Actual: " + actual);
    if (topPairs.size() > 0) {
      m_writer.print(" (" + topPairs.get(0).getScore() + ")");
    }
    m_writer.println();
    if (alt != null) {
      m_writer.println("      Alts: " + alt);
    }
    if (exemption != null) {
      if (exemption.isAssumeReference() == Boolean.FALSE) {
        m_writer.println("EXEMPTION: not assuming reference");
      }
      if (exemption.isAllHits() == Boolean.FALSE) {
        m_writer.println("EXEMPTION: top candidates only");
      }
    }
    m_writer.println();

    saveData(vcfFile, result);
  }

  private void saveData(Path vcfFile, Result result) throws IOException {
    //noinspection UnstableApiUsage
    String baseFilename = com.google.common.io.Files.getNameWithoutExtension(vcfFile.getFileName().toString());
    Files.copy(vcfFile, m_outputDir.resolve(vcfFile.getFileName()), StandardCopyOption.REPLACE_EXISTING);
    sf_resultSerializer.toJson(result, m_outputDir.resolve(baseFilename + ".json"));
    sf_resultSerializer.toHtml(result, m_outputDir.resolve(baseFilename + ".html"));
  }
}
